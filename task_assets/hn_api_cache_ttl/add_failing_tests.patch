diff --git a/HackerNewsTests/FixturesCache/item_1001.json b/HackerNewsTests/FixturesCache/item_1001.json
new file mode 100644
index 0000000..2d6feff
--- /dev/null
+++ b/HackerNewsTests/FixturesCache/item_1001.json
@@ -0,0 +1,12 @@
+{
+  "id": 1001,
+  "by": "alice",
+  "time": 1720000000,
+  "type": "story",
+  "title": "First story",
+  "text": "First story body",
+  "url": "https://example.com/first",
+  "score": 42,
+  "descendants": 5,
+  "kids": [2001, 2002]
+}
diff --git a/HackerNewsTests/FixturesCache/item_1002.json b/HackerNewsTests/FixturesCache/item_1002.json
new file mode 100644
index 0000000..7c822c5
--- /dev/null
+++ b/HackerNewsTests/FixturesCache/item_1002.json
@@ -0,0 +1,11 @@
+{
+  "id": 1002,
+  "by": "bob",
+  "time": 1720003600,
+  "type": "story",
+  "title": "Second story",
+  "url": "https://example.com/second",
+  "score": 7,
+  "descendants": 0,
+  "kids": []
+}
diff --git a/HackerNewsTests/FixturesCache/topstories.json b/HackerNewsTests/FixturesCache/topstories.json
new file mode 100644
index 0000000..bca21aa
--- /dev/null
+++ b/HackerNewsTests/FixturesCache/topstories.json
@@ -0,0 +1 @@
+[1001, 1002]
diff --git a/HackerNewsTests/HNApiCacheTests.swift b/HackerNewsTests/HNApiCacheTests.swift
new file mode 100644
index 0000000..8bf0b68
--- /dev/null
+++ b/HackerNewsTests/HNApiCacheTests.swift
@@ -0,0 +1,169 @@
+import Common
+import Foundation
+import XCTest
+
+final class HNApiCacheTests: XCTestCase {
+
+  override func setUpWithError() throws {
+    StubURLProtocol.responses = try FixtureLoader.responses()
+    StubURLProtocol.requestedURLs = []
+  }
+
+  override func tearDownWithError() throws {
+    StubURLProtocol.responses = [:]
+    StubURLProtocol.requestedURLs = []
+  }
+
+  func testFetchStoriesUsesCacheWithinTTL() async throws {
+    let clock = TestClock(start: Date(timeIntervalSince1970: 0))
+    let cache = HNApiInMemoryCache(ttlSeconds: 60, clock: clock)
+    let api = HNApi(session: try makeSession(), cache: cache)
+
+    let first = await api.fetchStories(feedType: .top)
+
+    XCTAssertEqual(first, [Int64(1001), 1002])
+
+    StubURLProtocol.responses = [:]
+    StubURLProtocol.requestedURLs = []
+
+    let second = await api.fetchStories(feedType: .top)
+
+    XCTAssertEqual(second, first)
+    XCTAssertEqual(StubURLProtocol.requestedURLs, [])
+  }
+
+  func testFetchStoriesCacheExpires() async throws {
+    let clock = TestClock(start: Date(timeIntervalSince1970: 0))
+    let cache = HNApiInMemoryCache(ttlSeconds: 60, clock: clock)
+    let api = HNApi(session: try makeSession(), cache: cache)
+
+    _ = await api.fetchStories(feedType: .top)
+
+    clock.advance(seconds: 61)
+    StubURLProtocol.requestedURLs = []
+
+    _ = await api.fetchStories(feedType: .top)
+
+    XCTAssertEqual(
+      StubURLProtocol.requestedURLs,
+      ["https://hacker-news.firebaseio.com/v0/topstories.json"]
+    )
+  }
+
+  func testFetchPageUsesItemCacheWithinTTL() async throws {
+    let clock = TestClock(start: Date(timeIntervalSince1970: 0))
+    let cache = HNApiInMemoryCache(ttlSeconds: 60, clock: clock)
+    let api = HNApi(session: try makeSession(), cache: cache)
+    let page = Page(ids: [Int64(1001), 1002][...])
+
+    let first = await api.fetchPage(page: page)
+
+    XCTAssertEqual(first.map(\.id), [Int64(1001), 1002])
+
+    StubURLProtocol.responses = [:]
+    StubURLProtocol.requestedURLs = []
+
+    let second = await api.fetchPage(page: page)
+
+    XCTAssertEqual(second.map(\.id), [Int64(1001), 1002])
+    XCTAssertEqual(StubURLProtocol.requestedURLs, [])
+  }
+
+  private func makeSession() throws -> URLSession {
+    let config = URLSessionConfiguration.ephemeral
+    config.protocolClasses = [StubURLProtocol.self]
+    return URLSession(configuration: config)
+  }
+}
+
+private final class TestClock: HNApiClock {
+  private var current: Date
+
+  init(start: Date) {
+    self.current = start
+  }
+
+  func now() -> Date {
+    current
+  }
+
+  func advance(seconds: TimeInterval) {
+    current = current.addingTimeInterval(seconds)
+  }
+}
+
+private enum FixtureLoader {
+  static func responses() throws -> [String: Data] {
+    return [
+      "https://hacker-news.firebaseio.com/v0/topstories.json": try data(
+        named: "topstories.json"),
+      "https://hacker-news.firebaseio.com/v0/item/1001.json": try data(
+        named: "item_1001.json"),
+      "https://hacker-news.firebaseio.com/v0/item/1002.json": try data(
+        named: "item_1002.json"),
+    ]
+  }
+
+  static func data(named name: String) throws -> Data {
+    let testsDir = URL(fileURLWithPath: #filePath)
+      .deletingLastPathComponent()
+    let fixturesDir = testsDir.appendingPathComponent("FixturesCache")
+    let url = fixturesDir.appendingPathComponent(name)
+    if !FileManager.default.fileExists(atPath: url.path) {
+      throw FixtureError.missingFixture(url.lastPathComponent)
+    }
+    return try Data(contentsOf: url)
+  }
+}
+
+private enum FixtureError: Error, CustomStringConvertible {
+  case missingFixture(String)
+
+  var description: String {
+    switch self {
+    case .missingFixture(let name):
+      return "Missing fixture: \(name)"
+    }
+  }
+}
+
+final class StubURLProtocol: URLProtocol {
+  static var responses: [String: Data] = [:]
+  static var requestedURLs: [String] = []
+
+  override class func canInit(with request: URLRequest) -> Bool {
+    true
+  }
+
+  override class func canonicalRequest(for request: URLRequest) -> URLRequest {
+    request
+  }
+
+  override func startLoading() {
+    guard let url = request.url else {
+      client?.urlProtocol(self, didFailWithError: FixtureError.missingFixture("URL"))
+      return
+    }
+
+    let key = url.absoluteString
+    StubURLProtocol.requestedURLs.append(key)
+
+    guard let data = StubURLProtocol.responses[key] else {
+      client?.urlProtocol(self, didFailWithError: FixtureError.missingFixture(key))
+      return
+    }
+
+    let response = HTTPURLResponse(
+      url: url,
+      statusCode: 200,
+      httpVersion: nil,
+      headerFields: nil
+    )!
+    client?.urlProtocol(self, didReceive: response, cacheStoragePolicy: .notAllowed)
+    client?.urlProtocol(self, didLoad: data)
+    client?.urlProtocolDidFinishLoading(self)
+  }
+
+  override func stopLoading() {
+  }
+}
